\newcommand{\symex}{\mathbb{S}}

\newcommand{\constantprop}{\mathbb{CO}}
\newcommand{\constraints}{\mathbb{C}}
\newcommand{\location}{\mathbb{L}}
\newcommand{\composition}{\mathscr{C}}

\newcommand{\transfer}{\rightsquigarrow}
\newcommand{\gtransfer}{\overset{g}{\transfer}}
\newcommand{\strengthen}{\downarrow}

\newcommand{\valueset}{\mathscr{Z}}
\newcommand{\integerset}{\mathbb{Z}}

\newcommand{\symlattice}{\mathscr{E}}
\newcommand{\symidset}{S_I}
\newcommand{\symexpset}{S_E}

\newcommand{\constraintlattice}{\mathscr{C}}

\newcommand{\llbracket}{[\![}
\newcommand{\rrbracket}{]\!]}
\newcommand{\concretization}{\llbracket \cdot \rrbracket}
\newcommand{\lesserEqual}{\sqsubseteq}
\newcommand{\leastupperbound}{\sqcup}

\newcommand{\satisfies}{\vDash}

\section{Specification}
The symbolic execution CPA is a composite CPA of a \emph{location CPA}, a \emph{symbolic value CPA} which tracks and computes the deterministic and non-deterministic values of variables and a \emph{constraints CPA}, which tracks encountered assumptions in form of constraints for each location's variables. The formal definitions of a composite CPA and location CPA are used as defined in \cite{Beyer2007}.

For the sake of formal simplicity, we assume that all values are integers.

\subsection{Symbolic value CPA}
The described CPA is an extension of the priorly mentioned value analysis CPA.
Instead of using a bottom element $\bot_{\valueset_\constantprop}$, we represent an unreachable state through the absence of a valid transfer.
The symbolic value CPA is defined as
\[\symex = (D_\symex, \transfer_\symex, merge^{sep}\ stop^{sep})\]
with abstract domain $D_\symex$, transfer relation $\transfer_\symex$, merge operator $merge^{sep}$ and stop operator $stop^{sep}$.

The abstract domain $D_\symex$ is defined as
$D_\symex = (C, \symlattice, \concretization )$
with $C$ being the set of concrete program states, $\symlattice$ the semi-lattice of possible abstract states and $\concretization$ the concretization function.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Beginn semi-lattice definition
%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\[\symlattice = (V_\symex,
                  \lesserEqual, 
                  \leastupperbound, 
                  v_\top
                )        
\]
The elements of the semi-lattice are total functions of $V_\symex = X \rightarrow (\valueset_\constantprop \cup \valueset_\symex)$ mapping program variables $X$ to a concrete value $\valueset_\constantprop = \integerset \cup {\top_\valueset}$
or to a symbolic value $\valueset_\symex = \symidset \cup \symexpset$.
$\symidset$ describes all symbolic identifiers and
$\symexpset$ is the set of all valid symbolic expressions. Each expression is a symbolic expression, if at least one symbolic identifier occurs in it.
%% Old, replaced by "if at least one symbolic identifier occurs in it"
%Symbolic expressions are inductively defined as follows:
%  (1) Each expression over concrete values and symbolic identifiers is a symbolic expression, if at least one symbolic identifier occurrs.
%  (2) Each expression over symbolic expressions is a symbolic expression. Formally, this can be expressed in the following way:
%  \begin{align*}
%    \text{(1) }& a, b \in (\symidset \cup \integerset) \text{ and } \{a, b\} \cap \symidset \neq \emptyset \Rightarrow (a \circ b) \in \symexpset \\
%    \text{(2) }& c, d \in S_E \Rightarrow (c \circ d) \in \symexpset
%  \end{align*}
%using $\circ \in \{+, -, *, / , \% , \ll , \gg , \&, |, \oplus\}$.
$\top_\valueset$ represents an unknown value.

The lesser-than-or-equal operator $\lesserEqual$ of $\symlattice$ is defined by
  \[ v \lesserEqual v' \Leftrightarrow \forall x \in X: v(x) = v'(x) \vee v'(x) = \top_\valueset\text{.} \]
The join $\leastupperbound$ holds the least upper bound of two lattice elements $v, v' \in V_\symex$ with
  \[ (v \leastupperbound v')(x) = \begin{dcases}
                    v(x) & \text{ if $v(x) = v'(x)$} \\
                  \top_\valueset & \text{ otherwise }
                \end{dcases}
  \].

The top element of $\symlattice$ is defined as $v_\top(x) = \top_\valueset$ for all $x \in X$. 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Ende semi-lattice definition
% Fortsetzung domain definition
%%%%%%%%%%%%%%%%%%%%%%%%%%%%

A concrete state $c \in C$ is \emph{compliant} to an abstract variable assignment $v$, if an arbitrary, but valid assignment of concrete values to symbolic identfiers $d: S_I \rightarrow \integerset$ exists, so that for all $x \in X$ one of the following conditions is fulfilled:
(1) the abstract assignment is a concrete value that equals the value in the concrete state, that means $c(x) = v(x)$,
(2) the abstract assignment $v(x)$ is a symbolic value that can be evaluated to $c(x)$ by replacing all occurring symbolic identifiers $i \in \symidset$ with $d(i)$, or
(3) $x$ has not occurred yet and as such has no concrete or symbolic value assigned, represented by $v(x) = \top_\valueset$.
The concretization function $\concretization$ then assigns all compliant concrete states to an abstract state $v$.

% Ende Domaene - Anfang Uebergangsfkt
The transfer relation $\transfer_\symex$ contains the transfer $v \gtransfer v''$, if one of the following conditions is true:
    \begin{enumerate}[1.]
      \item $g = (l, assume(p), l')$, $\phi (p, v)$ is satisfiable and for all $x \in X$:
        \[
          v''(x) = \begin{dcases}
            c    & \parbox[t]{.25\textwidth}{if $c$ only satisfying assignment for $\phi (p, v)$}\\
            y    & \parbox[t]{.25\textwidth}{if $v(x) = \top_\valueset$ and $x$ appears in $p$. $y \in S_I$ and y is a new value that has not been used in any other state before.}\\
            v(x) & \text{otherwise}              
          \end{dcases}
        \]
        with \[\phi (p, v) := p \wedge (\displaystyle\bigwedge_{x \in X,\atop {v(x) \in \integerset}} x = v(x))\]

        Note: $\phi$ performs an over-approximation, as only variables $x \in X$ with an explicit value are considered.

      \item $g = (l, w := e, l')$ and for all $x \in X$:
        \[
          v''(x) = \begin{dcases}
            eval(e, v') & \text{if $x = w$} \\
            v'(x)        & \text{otherwise}
          \end{dcases}
        \]
      with \[
         v'(x) = \begin{dcases}
            y    & \parbox[t]{.25\textwidth}{if $v(x) = \top_\valueset$ and $x$ appears in $e$. $y \in S_I$ and y is a new value that has not been used in any other state before.}\\
            v(x) & \text{otherwise}
          \end{dcases}
      \]
      and $eval(e, v')$ defined as the evaluation of an expression $e$ with the given assignment.
      If any symbolic value occurs in $v(e)$, it is only partially evaluated. In this case, $eval(e, v') \in \valueset_\symex$.

      \item $v'' = v_\top$.
    \end{enumerate}
The merge operator $merge^{sep}$ is defined as $merge^{sep}(e, e') = e'$.
The stop operator $stop^{sep}$ is defined as $stop^{sep}(e, R) = \exists e' \in R: e \lesserEqual e'$
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Beginn ConstraintsCPA
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Constraints CPA}

The constraints CPA is a CPA \[\constraints = (D_\constraints, \transfer_\constraints, merge^{sep}, stop^{sep})\] that tracks constraints (i.e. boolean formulas) on variables that are created by assume edges.
The abstract domain $D_\constraints$ is defined by 
\[D_\constraints = (C, \constraintlattice, \concretization)\]
with concrete states $C$, the semi-lattice $\constraintlattice$ and concretization function $\concretization$.

The abstract states described by $\constraintlattice = (2^\gamma, \lesserEqual, \leastupperbound, \top)$ consist of constraints of $\gamma$.
$\gamma$ contains all possible boolean expressions over $\valueset_\constantprop \cup \valueset_\symex$, including symbolic expressions.
An abstract state is interpreted as the conjunction of all its constraints.
%% Redundant with "all boolean expressions
%This can be expressed in the following formal way:
% \begin{align*}
%   \gamma = \gamma_B  \cup \{!a\ |\ a \in \gamma_B\}\\
%   \text{with } \gamma_B = \{a \circ b\ |\ a, b \in \symlattice\} \text{ and } \circ \in \{ ==, <, \leq , >, \geq \}\text{.}$
% \end{align*}

$\lesserEqual$ is defined as $a \lesserEqual a' \Leftrightarrow a' \subseteq a$,
the join $\leastupperbound$ as the intersection: $a \leastupperbound a' = a \cap a'$

The concretization function $\concretization$ maps an abstract state to all concrete states that satisfy this abstract state's constraints.
        \[ \llbracket a \rrbracket = \{ c \in C |\ c \satisfies \displaystyle\bigwedge_{\varphi \in a} \varphi \} \]
        Note: We assume that the empty conjunction represents true, that means $\displaystyle\bigwedge_{\varphi \in \{\}} \varphi = true$.

Constraint CPA's transfer relation $\transfer_\constraints$ contains the transfer $a \gtransfer_\constraints a'$ if one of the following conditions is fulfilled:
(1) $g = (l, assume(p), l')$, $a' = a \cup {p}$ and $a$ does not contain any variable $x \in X$
(By specifying that $a$ must not contain any variable we enforce that variables are always replaced by concrete (explicit or symbolic) values through strengthening), or
(2) $a' = a$ otherwise.

As $p$ is only added as a constraint if no variable of $X$ occurs in $a$, all resulting states of this transfer relation will be satisfiable, unless $p$ is a contradiction ($a \neq a$, for instance). Because of this, we completely disregard checking for satisfiability of constraints here.
Instead, we rely on satisfiability checks during strengthening by other CPAs.
In the following we will use the priorly defined symbolic value CPA to replace newly added constraints' variables with values and check for the whole state's satisfiability.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Beginn Composition
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Composition of CPAs}
$\composition_{\location\symex\constraints} = (\location, \symex, \constraints, \transfer_x, merge^{sep}, stop^{sep})$ is the composite CPA of a location CPA and the priorly defined symbolic value CPA and constraints CPA.
The transfer relation \[\transfer_x : D_\location \times D_\symex \times D_\constraints \rightarrow D_\location \times D_\symex \times D_\constraints\] contains
the transfer $(l, v, a) \gtransfer_x (l', v', a'')$ if 
            $l \gtransfer_\location l'$,
            $v \gtransfer_\symex v'$ and
            $a \gtransfer_\constraints a'$ and
            if the strengthen operation $\strengthen_{\constraints, \symex}$ is defined for $a'$ and $v'$ with
            $\strengthen_{\constraints, \symex} (a', v') = a''$.

The strengthen operator $\strengthen_{\constraints, \symex} : \constraints \times \symex \rightarrow \constraints$ uses the value assignment $v(x)$ of the given second operand to replace variables of the latest, unstrengthened constraint of the given constraints state. This way, meaningful constraints are created that show relations between symbolic values and can be checked for satisfiability.

$\strengthen_{\constraints, \symex} (a, v) = a'$ is defined if $a'$ is the result of replacing all program variables $x \in X$ occurring in $a$ with $v(x)$ and if $\displaystyle\bigwedge_{\varphi \in a'} \varphi$ is satisfiable.

\begin{figure*}

\begin{tikzpicture}[->,>=stealth, mynode/.style={circle, draw, minimum size=0.5cm, inner sep =0pt}, every node/.style={font=\small}]

  \node[mynode] (0) [label=0:{$(\{\}, \{\})$}]{0};
  \node[mynode] (1) [below = 0.5cm of 0, label=0:{$(\{a \rightarrow s1\}, \{\})$}]{1};
  \node[mynode] (2) [below left = 2cm of 1, label=west:{$(\{a \rightarrow s1\}, \{s1 < 0\})$}]{2};
  \node[mynode] (4) [below right = 2cm of 1, label=0:{$(\{a \rightarrow s1\}, \{s1 \geq 0\})$}]{4};
  \node[mynode] (3) [below = 0.5cm of 2, label=west:{$(\{a \rightarrow s1, b \rightarrow s1+1\}, \{s1 < 0\})$}]{3};
  \node[mynode] (5) [below = 0.5cm of 4, label=0:{$(\{a \rightarrow s1, b \rightarrow s1 \}, \{s1 \geq 0\})$}]{5};
  \node[mynode] (6) [below = 0.5cm of 3]{6};
  \node[mynode] (6n) [below = 0.5cm of 5]{6'};
  \node[mynode] (7) [below left = 1cm of 6, label=west:{$(\{a \rightarrow s1, b \rightarrow s1+1\}, \{s1 < 0, s1+1 \geq s1\})$}]{7};
  \node[mynode] (8) [below right = 1cm of 6, fill=gray]{8};
  \node[mynode] (8n) [below left = 1cm of 6n, fill=gray]{8'};
  \node[mynode] (7n) [below right = 1cm of 6n, label=0:{$(\{a \rightarrow s1, b \rightarrow s1\}, \{s1 < 0, s1 \geq s1\})$}]{7'};
  \coordinate[below = 0.5cm of 7] (e7);
  \coordinate[below = 0.5cm of 7n] (e7n);

  \path
    (0) edge node [right] {\textbf{a = \_\_nondet\_int()}} (1)
    (1) edge node [left, pos=0.5] {$\mathbf{![a \geq 0]}$} (2)
    (1) edge node [right, pos=0.5] {$\mathbf{[a \geq 0]}$} (4)
    (2) edge node [left] {\textbf{b = a + 1}} (3)
    (4) edge node [right] {\textbf{b = a}} (5)
    (3) edge (6)
    (5) edge (6n)
    (6) edge node [left, pos=0.5] {$\mathbf{![b < a]}$} (7)
    (6) edge node [right, pos=0.5] {$\mathbf{[b < a]}$} (8)
    (6n) edge node [left, pos=0.5] {$\mathbf{[b < a]}$} (8n)
    (6n) edge node [right, pos=0.5] {$\mathbf{![b < a]}$} (7n)
    (7) edge node [left] {\textbf{return 0}} (e7)
    (7n) edge node [right] {\textbf{return 0}} (e7n)
  ;
\end{tikzpicture}
\caption{Analysis of the program in listing \ref{exProg} by the symbolic execution CPA. The locations reported as unreachable are tinted grey. The state is provided as a tuple at each relevant node, the first element being the state of $\symex$, the second of $\constraints$. The state of the location CPA can be derived from the node's numbers.}
\label{constGraph}
\end{figure*}

An analysis of the previous test program using symbolic execution can be seen in figure \ref{constGraph}. 
By storing information about the relationship of variables $a$ and $b$, the CPA can derive at location 6/6' that $b$ can't be smaller than $a$.
