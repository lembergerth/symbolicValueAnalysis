\section{Evaluation}
The specified CPA was implemented in CPAchecker\cite{Beyer2011} using the existing CompositeCPA and LocationCPA.
The existing ValueAnalysisCPA  was extended to fulfil the specification of our symbolic value CPA,
while the constraints CPA was implemented as a new, own CPA. To check the satisfiability of constraints, an external SAT checker is used. For these benchmarks, MathSAT5 is used with the bitvector theory, encoding float values as floats.
The analysis is part of CPAchecker's trunk since revision 16052 and can be activated by using the configuration \texttt{valueAnalysis-symbolic}. As development is ongoing, the current revision at the time of this writing, that is 16071, was chosen for benchmarks.

Benchmarks were performed on a subset of the SV-COMP 2015 test set, excluding sets CPAchecker's ValueAnalysisCPA has no competency in.
These excluded sets are namely "Concurrency", "Memory Safety", "Recursive" and "Termination". An overview of all test sets can be found at \cite{SV15Benchmark}.
Tests were executed on an Intel Xeon E7-4870 at 2.40GHz with a memory limit of 15GB and a time limit of 900 seconds.

Figure \ref{tab:diff} shows the performance of the default ValueAnalysisCPA without counterexample-guided abstraction refinement (CEGAR) or counterexample checks next to the performance of our symbolic execution configuration. The category "timeouts" does not only include timeouts, but also two StackOverflowExceptions that resulted from long symbolic expressions. Such expressions can be generated by long loops, but are uncommon.
Generally speaking, basic value analysis easily outperforms symbolic execution in numbers.
Lots of timeouts occur due to
(a) path explosion, an exponential increase in possible paths based on the number of branches (that is if-statements and loops) as a result of the high precision of symbolic execution, and
(b) the bad performance of SAT checks with a large number of variables and arithmetic operations like multiplication.
Path explosion can easily been illustrated when looking at the algorithm statistics of a simple program using multiple if- and goto-statements:
While basic value analysis only needs about 3500 iterations to find a possible error, with the biggest waitlist consisting of 14 entries,
analysis with symbolic execution needs over 25000 iterations with the biggest waitlist consisting of almost 530 states.
In addition to this enormous growth in iterations, SAT checks are responsible for up to 95\% of CPU time in analyses of programs that are \emph{not} specifically constructed for challenging SAT checkers.

Despite this reduced speed, symbolic execution's ability to track non-deterministic values allows it to get a correct result in 41 cases in which value analysis does not. In eight of these value analysis receives timeouts, and in 33 value analysis provides a false positive. Symbolic execution does never produce a false result when value analysis produces a correct one.
\begin{figure}
\begin{tabular}{| r || r | r | r |}
\hline
        & Value & SymEx & Overall \\ \hline
correct                & 1994 &  475 & 3038 \\ \hline
true positives         &  631 &  322 &  802 \\ \hline
true negatives         & 1363 &  153 & 2236 \\ \hline
unique true positives  &  318 &    8 &    - \\ \hline
unique true negatives  & 1243 &   33 &    - \\ \hline
false positives        &  271 &   56 &    - \\ \hline
unique false positives &  220 &    5 &    - \\ \hline
false negatives        &    0 &    0 &    - \\ \hline 
timeouts               &  662 & 2451 &    - \\ \hline
errors                 &  111 &   56 &    - \\ \hline
\end{tabular}
\label{tab:diff}
\caption{Result of runs of value analysis (Value) and symbolic execution (SymEx) on SV-COMP 2015 test sets.
  "true positive" represents a found error in a program with an error,
  "true negative" represents no found error in a program without errors.}
\end{figure}

When using a timelimit of 1800 seconds, symbolic execution is able to compute 14 more results than with a timelimit of 900 seconds, of which eleven are correct.

Of these long-taking runs, five are the result of path explosion,
while the other nine only consist of few iterations, but contain expressions resulting in long-taking SAT checks, namely bitvector computations, non-deterministic floats and multiplications.

Some of these performance issues can be improved by using another theory in SAT checks.
By using an integer theory instead of bitvector, runtime could be decreased by up to 50\%, but resulted in a worse overall performance.
The use of integer results in an unsound analysis, too. Figure \ref{bitvecIntComp} shows the difference between the use of a bitvector theory with floats and the use of an integer theory.
\begin{figure}
\begin{tabular}{| r || r | r |}
\hline
& Bitvector theory & Integer theory \\ \hline
correct         &  475 &  461 \\ \hline
false positives &   56 &   97 \\ \hline
false negatives &    0 &    6 \\ \hline
timeouts        & 2450 & 2417 \\ \hline
errors          &   56 &   56 \\ \hline
                & & \\ \hline
\end{tabular}
\caption{Results of symbolic execution CPA using bitvector theory with floats and integer theory on SV-COMP 2015 test sets.}
\label{bitvecIntComp}
\end{figure}

Because of the obviously worse performance of integer theories, a bitvector theory should be used.
Instead, it should be tried to decrease runtime by tackling the problem of path explosion.
A valid approach to this could be CEGAR, which is already implemented for the ValueAnalysisCPA and is described in \cite{Beyer2012}.
By resolving the problem of path explosion, the number of iterations and as such also the number of SAT checks could be decreased.
This should be the main focus of future work.
